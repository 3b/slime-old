% esmb.tex
% Author: Torbjörn Törnkvist <tobbe@nortelnetworks.com>
% For the: ACM SIGPLAN Erlang Workshop - 2004
% (as part of: ACM SIGPLAN ICFP - 2004, Snowbird, Utah) 
% Revisions: 7 April 2004

\documentclass{acm_proc_article-sp}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{ACM SIGPLAN Erlang Workshop}{'04 Snowbird, Utah USA}
%\setpagenumber{50}
\CopyrightYear{2004} 
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (X-XXXXX-XX-X/XX/XX) to be over-ridden.
% --- End of Author Metadata ---

\title{An implementation of the SMB protocol in Erlang}
\numberofauthors{1}
\author{
\alignauthor Torbjörn Törnkvist\\
       \affaddr{Nortel Networks}\\
       \affaddr{P.O. Box 6701}\\
       \affaddr{113 85 Stockholm, Sweden}\\
       \email{tobbe@nortelnetworks.com}
}
\date{7 April 2004}
\maketitle
\begin{abstract}
  
This paper describes the implementation of a subset of the SMB
protocol in Erlang. We discuss the motivation for the work and the
outcome, with figures comparing this implementation with Samba
for performance and memory consumption.

\end{abstract}

\category{C.2.2}{Computer Communications}{Network Protocols}
\category{D.1}{Software}{Programming Techniques}
\category{D.1}{Software}{Programming Languages}

\section{Introduction}

This work started as a hobby project. The author wanted to learn more
about SMB (Server Message Block) \cite{cifs10}, the underlying
protocol of Microsoft's Windows Networking system. However, in his
profession the author is a developer of Nortel's SSL-VPN
product\footnote{A remote access security solution that extends the
  reach of enterprise applications and file systems to mobile workers,
  telecommuters, partners, and customers.}.  The SSL-VPN's control
system is written in Erlang, and it used the Open Source software
package \emph{Samba} \cite{sharpe:samba, eckstein:samba}
\footnote{Samba (www.samba.org) to access SMB file shares from Windows
  servers, and for some related tasks.
  
The Samba solution worked well to begin with, but it had some
drawbacks which became a significant problem after a time. Suddenly,
the author's hobby project could solve the SMB problems in the SSL-VPN
by replacing Samba.

\subsection{Problems to be solved}

One major problem was the size of the SSL-VPN software. Continually
adding new features was increasing the overall size of the software
and, despite attempts to trim the code down, we were reaching a limit.
Removing Sambda reduces the total code volume by 10\%.

Another problem was the high memory consumption of a Samba process
that we open via an Erlang port. One such process was opened for each
Windows server to be accessed. The port mechanism was also a potential
bottleneck since only one request-reply transaction could be served at
a time.

The SSL-VPN product was also being enhanced with internationalization
support. This would require us to modify the character handling
mechanism in Samba.

There were many more smaller problems. We had already had to make
small modifications to Samba to fit our needs, and these changes had
to be reconciled when importing new Samba releases. We also had little
control over the error messages that Samba produced.

\section{Some Erlang mechanisms}

We will assume that the reader has some knowledge of the Erlang
programming language. Therefore, we will only highlight a few language
mechanisms that are crucial for the rest of the discussion.

\subsection{Port programs}

Erlang is not just a programming language. It also emulates
its own little Operating System (for example: it has its own 
process scheduler and code loading mechanism.) When you start
Erlang, it runs as one process on the host operating 
system\footnote{In this article we will assume that Erlang
is running on Linux, or at least a Unix like OS}. To be able
to access external API's \footnote{Application Program Interface}
and other kinds of external software we can make use of the 
{\emph port} mechanism in Erlang. 

Opening a port causes the Erlang emulator to create a new OS process
to start the external program specified in the open-port command. A
pipe is created for communication between Erlang and the external port
program.

One good aspect of this mechanism is that any fatal error in the
external software will not affect the Erlang running Erlang system. A
drawback is that the context switch between the two processes may be
costly.

\subsection{Linked in drivers}

As an alternative to having the external software running in a
separate OS process, we can instead dynamically load the software
directly into the Erlang emulator. To do this we need to write some
``driver'' code according to the specified driver interface of Erlang.

With this approach we avoid the OS process context switches when
communicating between Erlang and the driver code.  On the other hand,
we will not be able to recover from a fatal error in the driver -- it
will crash the emulator itself.

\subsection{The Erlang Bit Syntax}

In Erlang, the \emph{Binary} data type denotes a chunk of raw bytes.
A Binary can for example be constructed by 3 elements as in:
\texttt{<<1, 2, 1024:16>>}, which creates a Binary consisting of 4
bytes, where the third byte is the most significant byte of the 16 bit
integer 1024 and the fourth byte is the least significant byte. The
value \emph{16} in this example is called a \emph{size expression}. It
specifies the size in \emph{units} that depend on the element type. In
this case where we have the default integer element type and the unit
is one bit.

A Binary can be deconstructed, or decoded, into segments by means of
pattern matching. A segment is a set of contiguous bits of the binary
(not necessarily on a byte boundary). The example below shows how we
can define a function \texttt{bitrev} that reverses the bit order of a
binary consisting of only one byte:

\begin{verbatim}
bitrev(<<A:1,B:1,C:1,D:1,E:1,F:1,G:1,F:1>>) ->
  <<F:1,G:1,E:1,D:1,C:1,B:1,A:1>>.
\end{verbatim}

By specifying a \emph{type specifier} for an element we can affect how
the element is coded with respect to \emph{signedness} and
\emph{endianness}. Since the SMB protocol represents integer values as
little endian, we can encode/decode such values in a very elegant
manner using the \emph{little} type specifier. For example, the
expression: \texttt{<<H:16/little, T/binary>> = Bin} will decodes a 16
bit integer in little-endian format and binds the result to the
variable \texttt{H}. The rest of the Binary will be bound to the
variable \texttt{T}.



\section{Using the SMB protocol}

The SMB protocol is a client server protocol that allows clients
to request access to resources on a server, and is the protocol 
that underlies the Microsoft Windows Networking prototocols. 
We will not dwelwe on the history of the SMB protocol here. 
The interested reader can find historical information 
in \cite{sharpe:samba}. One historical implication however is
that SMB runs over a protocol named NetBIOS, which in its turn 
can run over TCP as defined in \cite{rfc1001, rfc1002}.

There exists a number
of SMB implementations, where one of the most well known
(non-Microsoft) implementations is the Open Source implementation 
named Samba. Samba makes it 
possible to integrate other types of operating system into a Windows
network environment. For example, making Windows file shares 
available from a machine running Linux.

The Erlang control system of the Nortel SSL-VPN product
is interfacing Samba via an Erlang port program. Thus, clients
can manipulate file shares via the SSL-VPN product using
a Web browser interface.

The possible operations that can be performed via the SSL-VPN
Web portal are: list/create/remove directories and download/upload/delete files.
This means that only about a dozen SMB protocol messages
are used. 

Finally, the SSL-VPN is capable to list available shares on
a Windows machine. This functionality is using an extension
of the SMB protocol called the 
\emph{Lan Manager Remote Administration Protocol, (RAP)} 
which is an RPC like protocol running on top of SMB.


\section{The Implementation}

\subsection{Setup of a SMB session}

When we want to perform a file share operation on a SMB server
we need to setup a SMB session. We begin by doing a TCP-connect 
to the SMB server on the standard port 139. This is followed by 
the following four steps:

\begin{itemize}

\item {\em NetBIOS session setup} - After a TCP connection is established
a NetBIOS session is established between the client and the server. The
example below shows how every SMB PDU is prepended with a 4-byte NetBIOS
\texttt{Session-Service} header:
\begin{verbatim}
-define(SESSION_SERVICE, 16#00).

nbss_session_service_pdu(SMB_pdu) ->
  Length = size(SMB_pdu),
  <<?SESSION_SERVICE, 0, Length:16, 
    SMB_pdu/binary>>.
\end{verbatim}

\item {\em Protocol negotiation} - The SMB protocol allows for
the client and the server to negotiate for a compatible protocol
version \footnote{other names are: protocol variant or protocol dialect}. 
The result will for examlpe affect how authentication will be done. 
Another important parameter to be negotiated is whether to use \emph{Unicode} 
\footnote{http://www.unicode.org/} or not.

\item {\em Authentication} - This is done by sending a \texttt{Session-Setup}
SMB request, containing the \emph{Username} and \emph{Password}. 
Depending on what was negotiated earlier the password may be in cleartext
or encrypted. Also, depending on the protocol version used, there
are two ways of encrypting the password.

\item {\em Resource request} - The client sends a SMB \texttt{Tree-Connect}
request to the server containing the name of the disk share the client
wants to access. As a result, the server will return a tree identifier
(\emph{TID}) that the client need to provide in all the succeeding
protocol operations.

\end{itemize}

We are now ready to start issuing the SMB protocol messages that
represents the file system operations we want to perform.

\subsection{Encoding and Decoding SMB PDUs}

The encoding and decoding of the SMB messages are done by making use
of the Erlang bit syntax. Each SMB message consist of a 32 byte SMB header,
possibly followed by some associated data. In the example below, that
shows the encoding of a SMB message, we are using an Erlang record
to hold the SMB header information. The actual data has already been
encoded into Binaries:

\begin{verbatim}
enc_smb(Pdu) ->
  <<16#FF, $S, $M, $B,           % SMB header
   Pdu#smbpdu.cmd,               % SMB protocol OP
   Pdu#smbpdu.eclass,            % Error class
   0,                            % zero (not used)
   (Pdu#smbpdu.ecode):16/little, % Error code   
   Pdu#smbpdu.flags,             % Flags
   (Pdu#smbpdu.flags2):16/little,% More Flags
   0:12/unit:8,                  % Pad (12 bytes)
   (Pdu#smbpdu.tid):16/little,   % Tree ID
   (Pdu#smbpdu.pid):16/little,   % Process ID
   (Pdu#smbpdu.uid):16/little,   % User ID
   (Pdu#smbpdu.mid):16/little,   % Multiplex ID
   Pdu#smbpdu.wc,                % # of param.words
   (Pdu#smbpdu.wp)/binary,       % param.words
   (Pdu#smbpdu.bc):16/little,    % # of bytes
   (Pdu#smbpdu.bf)/binary>>.     % The bytes
\end{verbatim}
% $ - to fool the Emacs mode....

As can be seen from the example above, the bit syntax makes the encoding
trivial. Note in particular how we creates 
short integers in little endian format by using the
\texttt{little} type specifier.
This kind of construct is used both for encoding and decoding for
integers with a unit size larger than one byte. 

The following example shows how a \texttt{SMB-Close} PDU is
created:

\begin{verbatim}
smb_close_file_pdu(InReq) ->
  {Wc,Wp} = wp_close_file(InReq#smbpdu.fid),
  Rec = #smbpdu{cmd = ?SMB_CLOSE,
                pid = InReq#smbpdu.pid,
                uid = InReq#smbpdu.uid,
                tid = InReq#smbpdu.tid,
                flags2 = InReq#smbpdu.flags2,
                wc = Wc,
                wp = Wp},
  {Rec, enc_smb(Rec)}.

wp_close_file(Fid) ->
  {3,                % # of param.words
   <<Fid:16/little,  % File handle
     0:32/little>>}. % Time of last write 
                     % (0 == set by server)
\end{verbatim}

Note how we make use of the \texttt{enc\_smb} function
described earlier. The input parameter \texttt{InReq}
holds information that we have obtained in previous
SMB requests. In this case we are in particular interested 
in sending the file handle as data, to close the file 
it represents at the server.

\subsection{Unicode}

When Unicode has been negotiated, strings are sent encoded in
UTF-16 format. UTF-16 is an encoding 
scheme defined by the Unicode standard \cite{unicode:book}.
It is used for serializing the Unicode character representation
used on the Windows server. The SMB protocol is
defined so that multi-byte characters are to be sent in little
endian format.

The Nortel SSL-VPN product supports internationalization of the
Web portal presented to the users, which means that different
character sets (languages) may be used for different users.
This will require that we can convert strings in UTF-16LE format
(that we receive from the Windows server) into the character
set used by the user.

Fortunately, there is a command on Linux named \emph{iconv} that
can do this conversion. Since calling iconv were to be a frequent
operation, an Erlang linked in driver was developed. The example
below show how the code looks that converts from UTF-16LE into
another character set:

\begin{verbatim}
ucs2_to_charset(Str, Cset) ->
  case iconv:open(Cset, ?CSET_UTF16LE) of
    {ok, Cd} ->
      case iconv:conv(Cd, Str) of
        {ok, Res}       -> Res;
        {error, Reason} -> mk_unconv_str(Str, Cset)
      end;
    {error, Reason} ->
      mk_unconv_str(Str, Cset)
  end.

mk_unconv_str(Str, Cset) ->
  Qstr = string:copies("?", length(Str) div 2),
  ascii_to_charset(Qstr, Cset).
\end{verbatim} 

Note, in the example above, if the conversion fails, we will
return a string containing question marks.

\subsection{Authentication}

While developing the Erlang implementation of SMB, it was initially
very convenient to only negotiate the most basic of all the SMB
dialects: \emph{"PC NETWORK PROGRAM 1.0"}. This made it possible
to defer the implementation of encrypted passwords since encryption
is not supported in this protocol dialect. Later, when most of
the SMB implementation was working, by negotiating another protocol 
dialect, the encryption parts could be developed and tested separately.

There are two encryption methods used by the SMB protocol,
depending what protocol dialect that has been negotiated \cite{cifs10}.
Common to both methods are that a \emph{response} to a
\emph{challenge}, sent from the server, is computed by encrypting 
it with a \emph{session key} computed from the user's password.
The encryption is made by using a DES block mode encryption function.
The difference lies in how the session key is computed. In the first
method, the \emph{LM Session Key}, is computed by using 
the DES function. The second method, the \emph{NT session key},
is computed by a MD4 hash of the password represented in UTF-16LE.
To cater for the second method, an Erlang linked in driver was
developed to perform the MD4 hash.

The DES encryption is done by encrypting the challenge (which is always
8 bytes long) by the session key. The session key is always 21 bytes long
but needs to be chopped up in blocks of 7 bytes.
The example below show how the Erlang crypto library is used to
implement the encryption function\footnote{The function s2k/1 
converts a 7 character string (7 bytes, 8 bits per byte, total 56 bits) 
to a DES key (8 bytes, 7 bits per byte, total 56 bits). }:

\begin{verbatim}
ex(<<K0:7/binary,K1:7/binary,K2:7/binary>>,Data) ->
  concat_binary([e(K0,Data),e(K1,Data),e(K2,Data)]);

e(K,D) -> 
  crypto:des_cbc_encrypt(s2k(K), null_vector(), D).

null_vector() -> <<0,0,0,0,0,0,0,0>>.
\end{verbatim}

Worth to mention here is that in the CIFS-1.0 Technical
Reference \cite{cifs10} a bit swap operation, named \emph{swab} is 
included in the definition of how the \emph{NT Session Key} is
computed. After some trial and error we concluded that no such
function was used in reality.

\section{Evaluation}

What we wanted to evaluate was three things: performance,
memory consumption and the size of the release packages.

\subsection{Performance}

As explained earlier, we didn't do this work in order to
gain speed. However, we want to make sure that the performance
didn't decrease with the new solution. 

First we compared the performace of just one heavy SMB 
transaction, by fetching a 10 MB file.
The result is shown in table \ref{Tab1}.

\begin{table}[h]
\centering
\begin{tabular}{|c|r|r|} \hline
* & Samba & Esmb\\ \hline
portal-API & 4.0 MB/sec & 3,8 MB/sec\\ \hline
Web-portal & 2,6 MB/sec & 2,8 MB/sec\\ \hline
smbclient & 4,8 MB/sec & -\\ \hline
\hline\end{tabular}
\caption{Fetching a 10 MB file}
\label{Tab1}
\end{table}

The first line in table \ref{Tab1} shows the performance
through the lowest Erlang API (within the SSL-VPN software), 
comparing the original Samba based
implementation with the new Erlang implementation (\emph Esmb). 
We can see that the Erlang implementation is roughly 5\% slower
than the original implementation.

The second line shows the result when we download a 10 MB file 
all the way through the SSL-VPN Web portal software.
Here we suddently get the opposite performance figures.
The Erlang implementation is roughly 7\% faster. Both
implementations stream the content of the file towards
the client at the same rate that the data arrives from
the Windows server. 

The third line shows the performance of the \emph{smbclient}
program. It is included here only as a reference point.

Next we want to compare the system behaviour while lots
of users concurrently performs operations towards the 
Windows server.

Bla bla \ldots TO BE DONE \!\!\!

\subsection{Memory consumption}

With the old solution, each user accessing a SMB file
server would start a port program to interface Samba.
This caused a Linux processed to be created for each
user, consuming about 1.4 MB of memory. With memory
being a scarse resource this quickly sums up to
yield a maximum number of X concurrent users, accessing SMB
file shares.

The new solution vastly improve the situation \ldots bla bla

MORE MEASURMENTS TO BE DONE HERE \!\!\!

\subsection{Size}

With the old solution we had passed the maximum allowed size
of the unpacked software on disk, on a target machine.
 
The new solution decreases the size with 3.4 MB, which 
gives us roughly 3 MB for future expansion \footnote{NB: This
size restriction is irrelevant for our newest series of
hardware}.

\section{Conclusions}



Bla bla \ldots TO BE DONE \!\!\!

\section{Acknowledgments}

I want to thank a number of people that helped out
answering question, commenting the work or wrote
software I made use of. People that reviewed the paper
was: Johan Bevemyr, \ldots TO BE FILLED IN

Magnus Johanson wrote the test tool used for the measurements
in table \ref{Tab1}. Peter H\"{o}gfeldt helped out explaining how
the Erlang crypto library should be called.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
%\bibliography{esmb}  % esmb.bib is the name of the Bibliography in this case
\begin{thebibliography}{1}

\bibitem{armstrong:erlang}
J.~Armstrong, R.~Virding, C.~Wikström, and M.~Williams.
\newblock {\em Concurrent Programming in Erlang, 2:nd Edition}.
\newblock Prentice Hall, Englewood Cliffs, NJ, 1996.

\bibitem{eckstein:samba}
R.~Eckstein, D.~Collier-Brown, and P.~Kelley.
\newblock {\em Using Samba}.
\newblock O'Reilly Associates Inc, Sebastpol, CA, 2000.

\bibitem{unicode:book}
R.~Gilliam.
\newblock {\em Unicode Demystified}.
\newblock Addison Wesley, Boston, MA, 2002.

\bibitem{rfc1001}
N.~W. Group.
\newblock Protocol standard for a netbios service on a tcp/udp transport:
  Concepts and methods.
\newblock Technical Report RFC1001, IETF, Mar. 1987.

\bibitem{rfc1002}
N.~W. Group.
\newblock Protocol standard for a netbios service on a tcp/udp transport:
  Detailed specifications.
\newblock Technical Report RFC1002, IETF, Mar. 1987.

\bibitem{sharpe:samba}
R.~Sharpe, T.~Potter, and J.~Morris.
\newblock {\em Using Samba}.
\newblock QUE Publishing Company, Indianapolis, Indiana, 2000.

\bibitem{cifs10}
SNIA.
\newblock Common internet file system (cifs), technical reference.
\newblock Technical Report 1.0, Storage Networking Industry Association (SNIA),
  Jan. 2002.

\end{thebibliography}

% Replace the above with the contents of esmb.bbl when ready
%
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
\balancecolumns

% That's all folks!
\end{document}
